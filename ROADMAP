TODO plan:
Architectural tasks:
    1. SSDEEP responsese check
    2. Reply time check
    3. Mark both 1,2 as suspicious if stats has anomalies
    9. Add feature for starting fuzing process in parrallel:
        9.1 Add possibility to handle several files in several threads
    13. Add parameters from other hints and services (to HintsdB from APIGW)
        merge parameters from other hints and services, other variant /|\
    Additional tasks:
        types refactoring - make named tuple where required
    12. Try to addd lazy generator random_every_time$ with all other params which could be pairwise:
        id": (132, '#FUNC#random_every_time$'), "test": (1, 2, 3) means that for every permutation
        id will make different random numbers: "id": 1928399182, "test": 1, "id": 9898934982034, "test": 2, etc. make it
    15. Save data results during fuzzing

Business logic tasks:
    Make single k_v_Fuzzy object(mix to basic json sometimes <-- this case) OR test_method mix_it_sometimes
    Compare my fuzzer with this one - https://github.com/bahruzjabiyev/t-reqs-http-fuzzer
    4. Semantic mutation:  --> HARD
        4.1 action mytator by mutation testig tools(extract code or use tool as is to get mutated code bundle)
        4.2 JSON mutator - big project with semantic mutation, many questions how to realize
    6. RegEx generator (as UUID-regex or something else) - look here https://blog.intigriti.com/2021/03/17/bug-bytes-114-binary-fuzzing-for-web-vulnerabilities-leaky-page-nahamcon2021/
    7. Realize 1) lack of current parameter and 2) doubled one - DONE,
       can be realized easy with
        1) Fuzzy itself with any dataset value wich differs from base one
        2) One mode Fuzzy with all required params for curre nt JSON in corresponding place
           (e.g. for clientid create another dummy Fuzzy with "dummy" default name and clientid in dataset)
    14. Add structed mutations(testing with structly-correct random data input)
    16. Try to realize lamport talks for services to get error information
    17. I'm lucky parameter

Routine tasks:
    Add terms:
        tape, metadata, fuzzy, deck(jsons with add_data ready to send)
    Add work with default_value within dataset: data_set=(mutate_by_radamsa(default_value)),
    Recursively decrease delay between 500s for second check - PRIORITY_1
    5. Attach file with patterns for fuzzing  --> DONE
    8. Make sure that all items in tape are unique - DONE
    10. Add option for adding dir with custom generators/mutators
        First, post_json_fuzzer will try to find and registrate those generators in those folders
    11. Add fuzzer.log file with deep log info: as in  --> EASY
        https://s3.amazonaws.com/clickhouse-test-reports/33698/ea527ff7790372cd3ecb0bac111fd5af44c50103/fuzzer_astfuzzertsan,actions//fuzzer.log



Tasks for future:
    1. Add utility for making quick request for check if bug is fixed. E.g.: ./check_request -f ./results/disable_attack_type_dd_mm__yyyy/500 -n 12 (request is 12)
       It could be execute in bash loop script with i as -n(after all is fixed)
    2. from string import Template - try to replace str(dict)/smart_replace and others by substitute operation
    3. check if Python is > 3.6 because of potential using of named tuples
    4. *get_pack_by_methods("client_id", [list_once, list_several_times]) - try to add parameters for every function  --> DONE
    Watch JS-fromtend code for actions creation, compare with Nikita's variant in tests, try to compare them by statistical approach


Thoughts:
    all data_set items MUST be invalid, and only default value should be valid. This is important because we need to get json bodies with only wrong values
    try to apply a genetic algorithm to function fuzzing, i.e. mutate operators, add idempotent operations according to the rules of the genetic algorithm
    Idempotent functions for ast mutator will give coverage larger than just using basic function mutation?
    Add method for checking if API is fuzzable(has RPS > priemlemogo N bez deadlock oshibok etc.)
    AST-based action mutations - this is structure based mutation?
        Can it be coverage guided? Function-based mutation(actions by JS or Nikita) - is closer to semantic mutation?
    I need to check if there is project that allows to create functions that produces the same result
        as current function(for making several variants of functions which I can use for mutate operations within ast)
    Try to make decorator with request parameters for pytest requests via post_json_fuzzer
        (e.g. @params(headers={"one":1, "two": 2}def send_fuzz_requests() ...))